# Phase 3 Progress: Specialization Detection

## Session Start
Date: 2026-02-02
Previous Phases:

## Phase 3 Goal
Detect when agents evolve into different "species" with distinct strategies.
Prove that field enables DIVERSITY, not just higher reward.

## Key Insight from Phase 2
- Random field HURTS agents (585 < 600) → they learned to READ field
- Field might enable specialization, not just coordination

---

## Task Log

### US-001: Weight Divergence Metric ✓
**What:** Implemented `compute_weight_divergence()` and `flatten_agent_params()` in `src/analysis/specialization.py`.
**Decisions:**
- Used cosine distance (1 - cosine_similarity) as the divergence metric — standard for comparing high-dimensional weight vectors
- Supports alive_mask to only compare living agents
- Returns dict with mean_divergence, max_divergence, full divergence_matrix, and agent_indices
- Flattens all pytree leaves per-agent into a single 1D vector for comparison
**Files changed:**
- `src/analysis/specialization.py` (new) — `flatten_agent_params`, `compute_weight_divergence`
- `tests/test_specialization.py` (new) — 10 tests covering identical/different agents, symmetry, alive mask, edge cases, multi-leaf params
**Validation:** mypy clean, 184/184 tests pass

---

### US-002: Behavioral Feature Extraction ✓
**What:** Implemented `extract_behavior_features(trajectory)` in `src/analysis/specialization.py` that extracts 7 behavioral features per agent from trajectory data.
**Decisions:**
- Trajectory input is a simple dict of numpy arrays (actions, positions, rewards, alive_mask, energy, optional births/field_values) — keeps it generic and decoupled from US-003's TrajectoryRecorder
- 7 features per agent: movement_entropy, food_collection_rate, distance_per_step, reproduction_rate, mean_energy, exploration_ratio, action_stay_fraction
- Movement entropy normalized to [0,1] using scipy.stats.entropy / log(num_actions)
- Reproduction rate: uses explicit 'births' key if available, otherwise infers from action 5 count
- Dead agents (never alive in trajectory) get all-zero feature vectors
- Only alive steps are used for all metrics (via alive_mask filtering)
- Stay fraction counts both action 0 (stay) and action 5 (reproduce) since both keep agent stationary
- Added helper functions `_movement_entropy()`, `_distance_traveled()`, `_exploration_ratio()` for modularity
**Files changed:**
- `src/analysis/specialization.py` — added `extract_behavior_features`, `_movement_entropy`, `_distance_traveled`, `_exploration_ratio`; added `scipy.stats.entropy` import
- `tests/test_specialization.py` — added `TestBehaviorFeatures` class with 15 tests covering shape, finiteness, dead agents, deterministic/uniform entropy, food rate, distance, reproduction from births/actions, energy, exploration, stay fraction, partial alive, different agents
**Validation:** mypy clean, 199/199 tests pass

---

### US-003: Trajectory Recording ✓
**What:** Implemented `TrajectoryRecorder` class and `record_episode()` function in `src/analysis/trajectory.py` for recording per-agent, per-step data during evaluation episodes.
**Decisions:**
- `TrajectoryRecorder` is a simple append-based collector that stores per-step numpy arrays, then stacks them into a trajectory dict via `get_trajectory()`
- Accepts both JAX arrays and numpy arrays (converts to numpy on record)
- Optional fields: `births` (bool) and `field_values` (float) — only included in output if provided
- `record_episode()` runs a single episode using the same pattern as `video.py`'s `record_episode` (single env, Python loop)
- Supports both stochastic (default) and deterministic action modes via `deterministic` kwarg
- Births detected by comparing `agent_alive` before and after step (new alive = birth)
- Field values recorded as mean across channels at agent positions (using `read_local` with radius=0)
- `alive_mask` captures pre-step alive state (consistent with `extract_behavior_features` expectations)
- Output format directly compatible with `extract_behavior_features()` from US-002
**Files changed:**
- `src/analysis/trajectory.py` (new) — `TrajectoryRecorder` class, `record_episode()` function
- `tests/test_specialization.py` — added `TestTrajectoryRecording` class with 13 tests covering: basic shapes, num_steps property, empty raises, optional births/field_values, data preservation, JAX array acceptance, compatibility with behavior features, record_episode runs/shapes/births+field/deterministic/features pipeline/alive mask
**Validation:** mypy clean (31 files), 212/212 tests pass

---

### US-004: Behavioral Clustering ✓
**What:** Implemented `cluster_agents()` and `find_optimal_clusters()` in `src/analysis/specialization.py` for K-means-based behavioral clustering with silhouette score evaluation.
**Decisions:**
- Features are standardized (StandardScaler: zero mean, unit variance) before clustering so all features contribute equally regardless of scale
- `cluster_agents()` uses sklearn KMeans with n_init=10 for robust convergence
- n_clusters is clamped to the number of unique data points to avoid degenerate K-means
- Silhouette score guard: returns 0.0 when n_samples <= n_labels (sklearn requires n_samples > n_labels)
- `find_optimal_clusters()` tries k=2..min(max_k, n_unique) and picks the k with the highest silhouette score
- Degenerate cases (all identical features, single agent) gracefully return k=1 with silhouette=0.0
- Returns dict with labels, centroids (in standardized space), silhouette score, and n_clusters
**Files changed:**
- `src/analysis/specialization.py` — added `cluster_agents`, `find_optimal_clusters`; added sklearn imports (KMeans, silhouette_score, StandardScaler)
- `tests/test_specialization.py` — added `TestClustering` class with 15 tests covering: required keys, label shapes, centroid shapes, silhouette range, well-separated clusters, identical features, two agents, k clamping, find_optimal keys, correct k detection, silhouette_scores dict, identical data, single agent, reproducibility, full pipeline
**Validation:** mypy clean (31 files), 227/227 tests pass

---

### US-005: Specialization Score ✓
**What:** Implemented `specialization_score()` and `novelty_score()` in `src/analysis/specialization.py`.
**Decisions:**
- `specialization_score()` combines three normalized [0,1] components with configurable weights:
  - Silhouette component (weight 0.5): optimal clustering silhouette score clamped to [0,1] (negative values = poor clustering → 0)
  - Weight divergence component (weight 0.25): mean cosine distance / 2.0 (cosine distance range is [0,2])
  - Behavioral variance component (weight 0.25): tanh(mean variance of standardized features) — maps naturally to [0,1]
- When `agent_params` is None, divergence weight is redistributed equally to silhouette and variance components
- `novelty_score()` implements Lehman & Stanley (2011) k-NN distance metric
  - Uses `scipy.spatial.distance.cdist` for efficient Euclidean distance computation
  - Uses `np.argpartition` for O(n) k-nearest selection vs O(n log n) full sort
  - Gracefully handles edge cases: empty archive, k=0, k > archive_size
**Files changed:**
- `src/analysis/specialization.py` — added `specialization_score`, `novelty_score`; added `scipy.spatial.distance.cdist` import
- `tests/test_specialization.py` — added `TestSpecializationScore` (11 tests) and `TestNoveltyScore` (9 tests) covering: required keys, score range, identical/separated clusters, single agent, with/without params, component ranges, diversity ordering, custom weights, pipeline, output shape, non-negativity, identical-to-archive, novel agent, empty archive, k edge cases, single agent/archive, k=0
**Validation:** mypy clean (31 files), 247/247 tests pass

---

### US-006: Field Usage Analysis ✓
**What:** Implemented `analyze_field_usage()` and `_classify_cluster_role()` in `src/analysis/specialization.py`.
**Decisions:**
- Since all alive agents write to the field automatically (not action-dependent), "write frequency" = fraction of steps an agent is alive
- Per-cluster statistics computed: write_frequency, mean_field_value, field_value_std, movement_rate, spatial_spread, field_action_correlation
- Movement rate: fraction of alive steps where position changed (distinguishes movers from sitters)
- Spatial spread: unique positions / alive steps (how spread out an agent's trajectory is)
- Field-action correlation: Pearson correlation between field_value[t] and whether agent moved at step t+1 — captures whether agents are "guided" by the field
- Role classification heuristic: writers = high movement + low field values, readers = low movement + high field values, balanced = neither extreme
- Gracefully handles missing field_values key (returns 0.0 for field-based stats)
- Dead agents contribute zero to all metrics
**Files changed:**
- `src/analysis/specialization.py` — added `analyze_field_usage`, `_classify_cluster_role`
- `tests/test_specialization.py` — added `TestFieldUsage` class with 15 tests covering: required keys, num_clusters, per-cluster stats, cluster roles, write_frequency range, all-alive frequency, dead agent stats, stationary/moving agents, reader/writer detection, without field_values, single cluster, spatial_spread range, field_action_correlation range, full pipeline
**Validation:** mypy clean (31 files), 262/262 tests pass

---
